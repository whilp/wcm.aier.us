#!/usr/bin/env python

import logging
import os
import sys

from optparse import OptionParser, make_option as Option

from boto.s3.connection import S3Connection

try:
    NullHandler = logging.NullHandler
except AttributeError:
    class NullHandler(logging.Handler):
        def emit(self, record): pass

log = logging.getLogger(__name__)
log.addHandler(NullHandler())

def main():
    optparser = OptionParser(option_list=options)
    (opts, args) = optparser.parse_args()

    if not opts.silent:
        log.level = max(1, logging.WARNING - (10 * (opts.verbose - opts.quiet)))
        log.addHandler(logging.StreamHandler())

    bucketname = args[0]
    paths = (os.path.normpath(p.rstrip("\n")) for p in args[1:])

    log.debug("connecting to S3")
    conn = S3Connection()
    log.debug("getting bucket %r", bucketname)
    bucket = conn.get_bucket(bucketname)

    bucketsync(bucket, paths)

options = [
    Option("-q", "--quiet", default=0, action="count",
        help="decrease logging"),
    Option("-s", "--silent", default=False, action="store_true",
        help="silence logging"),
    Option("-v", "--verbose", default=0, action="count",
        help="increase logging"),
]

def bucketsync(bucket, paths, delete=True):
    keys = dict((k.name, k) for k in bucket.list())
    log.debug("found %d active keys in bucket %r", len(keys), bucket.name)

    for path in paths:
        key = keys.pop(path, None)
        if not key:
            log.debug("creating key %r", path)
            key = bucket.new_key(path)

        with open(path, 'rb') as fp:
            synckey(key, fp)

    if delete:
        # Any leftover keys have been removed locally and should be deleted from S3.
        for key in keys.values():
            log.debug("deleting key %r", key)
            key.delete()

def synckey(key, fp, public=True, **kwargs):
    name = key.name
    md5 = None
    if key.etag:
        etag = key.etag.strip("\"'")
        md5 = (md5sum, base64md5) = key.compute_md5(fp)
        if etag != md5sum:
            log.debug("MD5(%r)=%s does not match remote etag %s", name, md5sum, etag)
        else:
            log.debug("key %r is unchanged", name)
            # Local and S3 copies match.
            return

    log.debug("uploading key %r", name)
    key.set_contents_from_file(fp, md5=md5)
    if public:
        log.debug("making key %r public", name)
        key.make_public()

if __name__ == "__main__":
    try:
        ret = main()
    except KeyboardInterrupt:
        ret = None
    sys.exit(ret)
