#!/usr/bin/env python

import sys

from functools import partial
from itertools import dropwhile
from operator import not_

try:
    import mako.lookup
    import mako.template
except ImportError, e:
    mako = e

try:
    import misaka
except ImportError, e:
    misaka = e

try:
    import yaml
except ImportError, e:
    yaml = e

missing = [m for m in (mako, misaka, yaml) if isinstance(m, Exception)]

__all__ = ["Doc"]

def main():
    if missing:
        raise missing[0]

    fname = sys.argv[1]

    config = {}
    try:
        config = yaml.load(open("config"))
    except IOError, e:
        if e.errno != 2:
            raise

    html = misaka.Markdown(HTML5Compiler())
    templates = mako.lookup.TemplateLookup(
        directories=["templates"],
        )
    templates.put_string(None, "${body}")

    doc = Doc(meta=config,
        parse = compose(yaml.load, u"".join),
        compile = compose(HTML5Compiler(), u"".join),
        lookup = templates.get_template,
        )

    with open(fname) as input:
        input = iter(list(input))

    rendered = doc.render(input)

    with open(fname + ".html", 'w') as output:
        output.write(rendered)

class Doc(object):
    
    def __init__(self, meta=None, parse=None, compile=None, lookup=None):
        self.meta = meta if meta is not None else {}
        if parse is not None:
            self.parse = parse
        if compile is not None:
            self.compile = compile
        if lookup is not None:
            self.lookup = lookup

    def render(self, input):
        meta = self.meta.copy()

        header, body = self.split(input)
        meta.update(self.parse(header))
        meta.update(self.compile(body))

        return self.template(meta.get("template"), meta)

    def split(self, input):
        header = []
        for line in input:
            if not line.strip():
                break
            header.append(line)

        return header, input

    def parse(self, header):
        if isinstance(yaml, Exception):
            raise yaml
        return yaml.load("".join(header)) or []

    def compile(self, body):
        if isinstance(misaka, Exception):
            raise misaka
        return misaka.html("".join(body))

    def lookup(self, template):
        if isinstance(mako, Exception):
            raise mako
        return mako.template.Template("${body}")

    def template(self, template, meta):
        template = self.lookup(template)
        return template.render(**meta)

if not isinstance(misaka, Exception):
    class HTML5Compiler(misaka.HtmlRenderer):
        
        def setup(self):
            super(HTML5Compiler, self).setup()
            self.level = 0
            self.toc = []
            self.ids = {}

        def compile(self, body):
            yield "body", misaka.Markdown(self).render(body)
            yield "toc", self.toc

        __call__ = compile

        def header(self, text, level):
            out = []
            id = text2id(text)
            count = self.ids[id] = self.ids.setdefault(id, 0) + 1
            if count > 1:
                id += "-%d" % count

            if level <= self.level:
                self.toc.append("")
                self.toc.extend("</ul>" for x in range(level, self.level))

                out.append("")
                out.extend("</section>" for x in range(level, self.level + 1))
                out.append("")
            elif 0 < self.level < level:
                self.toc.append("<ul>")
                out.append("")

            self.level += cmp(level, self.level)

            self.toc.append((
                '<li><a href="#{id}">{text}</a></li>'.format(
                    id=id, text=text,
                )))

            out.extend((
                '<section id="{id}">',
                    "<header>",
                        "<{tag}>{text}</{tag}>",
                    "</header>",
                    "",
                ))
            return "\n".join(out).format(
                text=text,
                level=level,
                tag="h%d" % level,
                id=id,
                )

        def doc_header(self):
            self.toc.append("<ul>")

        def doc_footer(self):
            self.toc.extend("</ul>" for x in range(self.level))
            return "\n".join("</section>" for x in range(self.level))

        def postprocess(self, doc):
            self.toc = "\n".join(self.toc)

            if not doc.endswith("\n"):
                doc += "\n"
            return doc

def compose2(outer, inner):
    def composed(input):
        return outer(inner(input))
    return composed

compose3 = partial(reduce, compose2)

def compose(*fns):
    return compose3(fns)

# http://www.w3.org/TR/html4/types.html#type-name
idchar = lambda x: x.isalpha() or x.isdigit() or x in "-_:."
replace = lambda old, new, s: s.replace(old, new)
split = lambda sep, s: s.split(sep)
text2id = compose(
    u"".join,
    partial(filter, idchar),
    partial(dropwhile, compose(not_, unicode.isalpha)),
    u"-".join,
    partial(split, None),
    )

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit()
